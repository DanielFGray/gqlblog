// WARNING: This file is automatically generated. Do not edit.
/* eslint-disable */
import { GraphQLResolveInfo } from 'graphql';
import gql from 'graphql-tag';
import * as ApolloReactCommon from '@apollo/react-common';
import * as ApolloReactHooks from '@apollo/react-hooks';
export type Maybe<T> = T | null;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };


/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string,
  String: string,
  Boolean: boolean,
  Int: number,
  Float: number,
};

export type Blog = {
  title: Scalars['String'],
  category: Scalars['String'],
  tags?: Maybe<Array<Maybe<Scalars['String']>>>,
  date?: Maybe<Scalars['Float']>,
  words?: Maybe<Scalars['Int']>,
  readTime?: Maybe<Scalars['String']>,
  id: Scalars['String'],
  url: Scalars['String'],
  content?: Maybe<Scalars['String']>,
  excerpt?: Maybe<Scalars['String']>,
};

export type GitActivity = {
  url: Scalars['String'],
  name: Scalars['String'],
  updated?: Maybe<Scalars['Float']>,
  stars: Scalars['Int'],
  issues?: Maybe<Scalars['Int']>,
  forks: Scalars['Int'],
  description?: Maybe<Scalars['String']>,
  language?: Maybe<Scalars['String']>,
  branches?: Maybe<Array<GitBranch>>,
};

export type GitBranch = {
  message: Scalars['String'],
  committedDate: Scalars['Float'],
};

export type Query = {
  GitActivity: Array<Maybe<GitActivity>>,
  BlogList: Array<Maybe<Blog>>,
  BlogPost?: Maybe<Blog>,
};


export type QueryBlogPostArgs = {
  id: Scalars['String']
};

export type BlogListQueryVariables = {};


export type BlogListQuery = { BlogList: Array<Maybe<Pick<Blog, 'id' | 'title' | 'category' | 'url' | 'date' | 'tags' | 'excerpt' | 'words' | 'readTime'>>> };

export type BlogPostQueryVariables = {
  id: Scalars['String']
};


export type BlogPostQuery = { BlogPost: Maybe<Pick<Blog, 'id' | 'title' | 'category' | 'url' | 'date' | 'tags' | 'content' | 'words' | 'readTime'>> };

export type GitActivityQueryVariables = {};


export type GitActivityQuery = { GitActivity: Array<Maybe<(
    Pick<GitActivity, 'url' | 'name' | 'description' | 'updated' | 'stars' | 'issues' | 'forks' | 'language'>
    & { branches: Maybe<Array<Pick<GitBranch, 'committedDate' | 'message'>>> }
  )>> };



export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;


export type StitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes>;

export type isTypeOfResolverFn<T = {}> = (obj: T, info: GraphQLResolveInfo) => boolean;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Query: ResolverTypeWrapper<{}>,
  GitActivity: ResolverTypeWrapper<GitActivity>,
  String: ResolverTypeWrapper<Scalars['String']>,
  Float: ResolverTypeWrapper<Scalars['Float']>,
  Int: ResolverTypeWrapper<Scalars['Int']>,
  GitBranch: ResolverTypeWrapper<GitBranch>,
  Blog: ResolverTypeWrapper<Blog>,
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>,
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Query: {},
  GitActivity: GitActivity,
  String: Scalars['String'],
  Float: Scalars['Float'],
  Int: Scalars['Int'],
  GitBranch: GitBranch,
  Blog: Blog,
  Boolean: Scalars['Boolean'],
};

export type BlogResolvers<ContextType = any, ParentType extends ResolversParentTypes['Blog'] = ResolversParentTypes['Blog']> = {
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  category?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  tags?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>,
  date?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,
  words?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,
  readTime?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  content?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,
  excerpt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,
  __isTypeOf?: isTypeOfResolverFn<ParentType>,
};

export type GitActivityResolvers<ContextType = any, ParentType extends ResolversParentTypes['GitActivity'] = ResolversParentTypes['GitActivity']> = {
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  updated?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>,
  stars?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,
  issues?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>,
  forks?: Resolver<ResolversTypes['Int'], ParentType, ContextType>,
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,
  language?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>,
  branches?: Resolver<Maybe<Array<ResolversTypes['GitBranch']>>, ParentType, ContextType>,
  __isTypeOf?: isTypeOfResolverFn<ParentType>,
};

export type GitBranchResolvers<ContextType = any, ParentType extends ResolversParentTypes['GitBranch'] = ResolversParentTypes['GitBranch']> = {
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>,
  committedDate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>,
  __isTypeOf?: isTypeOfResolverFn<ParentType>,
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  GitActivity?: Resolver<Array<Maybe<ResolversTypes['GitActivity']>>, ParentType, ContextType>,
  BlogList?: Resolver<Array<Maybe<ResolversTypes['Blog']>>, ParentType, ContextType>,
  BlogPost?: Resolver<Maybe<ResolversTypes['Blog']>, ParentType, ContextType, RequireFields<QueryBlogPostArgs, 'id'>>,
};

export type Resolvers<ContextType = any> = {
  Blog?: BlogResolvers<ContextType>,
  GitActivity?: GitActivityResolvers<ContextType>,
  GitBranch?: GitBranchResolvers<ContextType>,
  Query?: QueryResolvers<ContextType>,
};


/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
*/
export type IResolvers<ContextType = any> = Resolvers<ContextType>;


export const BlogListDocument = gql`
    query BlogList {
  BlogList {
    id
    title
    category
    url
    date
    tags
    excerpt
    words
    readTime
  }
}
    `;

/**
 * __useBlogListQuery__
 *
 * To run a query within a React component, call `useBlogListQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlogListQuery` returns an object from Apollo Client that contains loading, error, and data properties 
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlogListQuery({
 *   variables: {
 *   },
 * });
 */
export function useBlogListQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<BlogListQuery, BlogListQueryVariables>) {
        return ApolloReactHooks.useQuery<BlogListQuery, BlogListQueryVariables>(BlogListDocument, baseOptions);
      }
export function useBlogListLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<BlogListQuery, BlogListQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<BlogListQuery, BlogListQueryVariables>(BlogListDocument, baseOptions);
        }
export type BlogListQueryHookResult = ReturnType<typeof useBlogListQuery>;
export type BlogListLazyQueryHookResult = ReturnType<typeof useBlogListLazyQuery>;
export type BlogListQueryResult = ApolloReactCommon.QueryResult<BlogListQuery, BlogListQueryVariables>;
export const BlogPostDocument = gql`
    query BlogPost($id: String!) {
  BlogPost(id: $id) {
    id
    title
    category
    url
    date
    tags
    content
    words
    readTime
  }
}
    `;

/**
 * __useBlogPostQuery__
 *
 * To run a query within a React component, call `useBlogPostQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlogPostQuery` returns an object from Apollo Client that contains loading, error, and data properties 
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlogPostQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBlogPostQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<BlogPostQuery, BlogPostQueryVariables>) {
        return ApolloReactHooks.useQuery<BlogPostQuery, BlogPostQueryVariables>(BlogPostDocument, baseOptions);
      }
export function useBlogPostLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<BlogPostQuery, BlogPostQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<BlogPostQuery, BlogPostQueryVariables>(BlogPostDocument, baseOptions);
        }
export type BlogPostQueryHookResult = ReturnType<typeof useBlogPostQuery>;
export type BlogPostLazyQueryHookResult = ReturnType<typeof useBlogPostLazyQuery>;
export type BlogPostQueryResult = ApolloReactCommon.QueryResult<BlogPostQuery, BlogPostQueryVariables>;
export const GitActivityDocument = gql`
    query GitActivity {
  GitActivity {
    url
    name
    description
    updated
    stars
    issues
    forks
    language
    branches {
      committedDate
      message
    }
  }
}
    `;

/**
 * __useGitActivityQuery__
 *
 * To run a query within a React component, call `useGitActivityQuery` and pass it any options that fit your needs.
 * When your component renders, `useGitActivityQuery` returns an object from Apollo Client that contains loading, error, and data properties 
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGitActivityQuery({
 *   variables: {
 *   },
 * });
 */
export function useGitActivityQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<GitActivityQuery, GitActivityQueryVariables>) {
        return ApolloReactHooks.useQuery<GitActivityQuery, GitActivityQueryVariables>(GitActivityDocument, baseOptions);
      }
export function useGitActivityLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GitActivityQuery, GitActivityQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<GitActivityQuery, GitActivityQueryVariables>(GitActivityDocument, baseOptions);
        }
export type GitActivityQueryHookResult = ReturnType<typeof useGitActivityQuery>;
export type GitActivityLazyQueryHookResult = ReturnType<typeof useGitActivityLazyQuery>;
export type GitActivityQueryResult = ApolloReactCommon.QueryResult<GitActivityQuery, GitActivityQueryVariables>;